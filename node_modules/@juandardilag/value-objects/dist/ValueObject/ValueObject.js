"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ValueObject = void 0;
const tslib_1 = require("tslib");
const InvalidArgumentError_1 = require("./errors/InvalidArgumentError");
class ValueObject {
    constructor(_options, _value) {
        this._options = _options;
        this._value = _value;
        const validation = this.validate(_value);
        if (validation instanceof Error) {
            throw validation;
        }
    }
    get value() {
        return this._value;
    }
    set value(value) {
        if (!this.validate(value)) {
            throw new InvalidArgumentError_1.InvalidArgumentError(this.constructor.name, value);
        }
        this._value = value;
    }
    equal(other) {
        if (other === null || other === undefined) {
            return false;
        }
        if (this.constructor.name !== other.constructor.name) {
            return false;
        }
        return this.value === other.value;
    }
    isBiggerThan(other) {
        if (other === null || other === undefined) {
            return false;
        }
        if (typeof this.value !== typeof other.value) {
            return false;
        }
        return this.value > other.value;
    }
    is(o) {
        return this._value === o;
    }
    toString() {
        if (this._value) {
            return this._value.toString();
        }
        return this._value;
    }
    validate(val) {
        const validation = this._options.validatable.validate(val);
        if (validation instanceof Error) {
            return validation;
        }
        if (validation === false) {
            return new InvalidArgumentError_1.InvalidArgumentError(this.constructor.name, val);
        }
    }
    add(other) {
        return this._options.operable.add(this, other);
    }
    encrypt(val) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this._options.pii) {
                throw new Error("Cannot encrypt non-PII");
            }
            return this._options.operable.encrypt(val);
        });
    }
    decrypt(val) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this._options.pii) {
                throw new Error("Cannot decrypt non-PII");
            }
            return this._options.operable.decrypt(val);
        });
    }
}
exports.ValueObject = ValueObject;
